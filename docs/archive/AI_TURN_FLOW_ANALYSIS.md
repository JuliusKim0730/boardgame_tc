# AI 턴 실행 흐름 분석

## 전체 흐름도

```
[AIScheduler - 5초마다 체크]
    ↓
[AI 턴 감지] (is_ai = true, status = 'running')
    ↓
[executingGames에 추가] (중복 실행 방지)
    ↓
[AIPlayerService.executeTurn 호출]
    ↓
┌─────────────────────────────────────┐
│ 1. 게임 상태 조회 (읽기 전용)        │ ← DB 연결/해제
│    - 게임 정보, 플레이어 상태        │
│    - 손패, 여행지 테마 등            │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 2. 이동 결정 (decideMove)           │ ← 로컬 계산
│    - 인접 칸 계산                    │
│    - 우선순위 점수 계산              │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 3. 이동 실행 (moveWithTransaction)  │ ← DB 트랜잭션 (재시도 3회)
│    - player_states 업데이트          │   타임아웃: 10초
│    - event_logs 기록                 │   재시도 간격: 1초, 2초, 3초
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 4. 행동 실행 (performAction)        │ ← DB 트랜잭션 (재시도 3회)
│    - 덱에서 카드 드로우              │   타임아웃: 10초
│    - 손패에 추가 (plan/freeplan)    │
│    - TC 효과 적용 (house/support)   │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 5. WebSocket 브로드캐스트           │ ← 프론트엔드 알림
│    - 'game-state-updated' 이벤트    │
│    - 룸의 모든 클라이언트에 전송    │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 6. 결심 토큰 사용 결정               │ ← 확률 기반
│    - Day 2-5: 확률적 사용           │
│    - Day 10-12: 확률적 사용         │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 7. 턴 종료 (TurnManager.endTurn)    │ ← DB 트랜잭션
│    - turns 테이블 업데이트           │
│    - 다음 플레이어 결정              │
│    - 날짜 전환 체크                  │
└─────────────────────────────────────┘
    ↓
[executingGames에서 제거]
    ↓
[2초 대기] (자연스러운 플레이)
    ↓
[다음 AI 턴 체크]
```

## 시간 소요 분석

### 1. AIScheduler 체크 주기
- **간격**: 5초마다
- **딜레이**: 최대 5초 (마지막 체크 직후 턴이 넘어온 경우)

### 2. 게임 상태 조회
- **예상 시간**: 100-300ms
- **DB 쿼리**: 
  - 게임 정보 조회
  - 플레이어 상태 조회
  - 손패 조회
  - 여행지 테마 조회

### 3. 이동 결정
- **예상 시간**: 1-5ms (로컬 계산)
- **처리**: 인접 칸 계산, 점수 계산

### 4. 이동 실행
- **예상 시간**: 50-200ms (정상)
- **타임아웃**: 10초
- **재시도**: 최대 3회 (1초, 2초, 3초 간격)
- **최악의 경우**: 10초 + 1초 + 10초 + 2초 + 10초 = 33초

### 5. 행동 실행
- **예상 시간**: 100-500ms (정상)
- **타임아웃**: 10초
- **재시도**: 최대 3회
- **최악의 경우**: 33초

### 6. WebSocket 브로드캐스트
- **예상 시간**: 10-50ms
- **처리**: 룸 ID 조회 + 이벤트 발송

### 7. 결심 토큰 사용
- **예상 시간**: 100-500ms (사용 시)
- **확률**: Day에 따라 다름

### 8. 턴 종료
- **예상 시간**: 100-300ms
- **처리**: 
  - turns 업데이트
  - 다음 플레이어 결정
  - 날짜 전환 체크

### 9. 완료 후 대기
- **고정 딜레이**: 2초

## 총 소요 시간

### 정상 케이스
```
5초 (체크 대기) + 
0.5초 (상태 조회 + 이동 결정) + 
0.2초 (이동 실행) + 
0.3초 (행동 실행) + 
0.05초 (WebSocket) + 
0.3초 (턴 종료) + 
2초 (대기)
= 약 8.35초
```

### 최악의 케이스 (타임아웃 + 재시도)
```
5초 (체크 대기) + 
0.5초 (상태 조회) + 
33초 (이동 재시도) + 
33초 (행동 재시도) + 
0.3초 (턴 종료) + 
2초 (대기)
= 약 73.8초
```

## 프론트엔드 동기화

### WebSocket 이벤트 흐름

1. **AI 턴 시작**
   - 백엔드: `TurnManager.startTurn()` → `turn-started` 이벤트
   - 프론트: `loadGameState()` 호출
   - 화면: "다른 플레이어의 턴입니다..." 표시

2. **AI 행동 완료**
   - 백엔드: `AIPlayerService.broadcastGameState()` → `game-state-updated` 이벤트
   - 프론트: `loadGameState()` 호출
   - 화면: 게임 상태 업데이트 (위치, 손패, 돈 등)

3. **AI 턴 종료**
   - 백엔드: `TurnManager.endTurn()` → `turn-started` 이벤트 (다음 플레이어)
   - 프론트: `loadGameState()` 호출
   - 화면: 다음 플레이어 턴 표시

### 프론트엔드 이벤트 리스너

```typescript
// 턴 시작
socket.on('turn-started', (data) => {
  setGameState(prev => ({ ...prev, currentTurnPlayerId: data.playerId }));
  loadGameState();
});

// 게임 상태 업데이트 (AI 행동 완료 시)
socket.on('game-state-updated', () => {
  console.log('📡 게임 상태 업데이트 수신');
  loadGameState();
});

// 행동 완료 (사용자 행동 시)
socket.on('action-completed', (data) => {
  setTimeout(() => loadGameState(true), 500);
});
```

## 발견된 문제점 및 모순

### ✅ 해결된 문제

1. **이중 해제 에러**
   - 문제: 재시도 시 `client.release()` 중복 호출
   - 해결: try-catch로 안전하게 처리

2. **타임아웃 에러**
   - 문제: 긴 트랜잭션으로 인한 락 충돌
   - 해결: 트랜잭션 분리 + 재시도 로직

3. **중복 실행**
   - 문제: 5초마다 체크하면서 중복 실행 가능
   - 해결: `executingGames` Set으로 중복 방지

4. **프론트엔드 미반영**
   - 문제: AI 행동 후 프론트엔드 업데이트 안됨
   - 해결: `game-state-updated` 이벤트 추가

### ⚠️ 잠재적 문제

1. **타임아웃 설정이 너무 김**
   - 현재: 10초 타임아웃
   - 문제: 최악의 경우 73초 소요
   - 제안: 타임아웃을 5초로 줄이고, 재시도 횟수 유지

2. **WebSocket 브로드캐스트 타이밍**
   - 현재: 행동 완료 직후 브로드캐스트
   - 문제: 트랜잭션이 커밋되기 전에 이벤트 발송 가능
   - 제안: 트랜잭션 커밋 후 브로드캐스트

3. **AIScheduler 체크 간격**
   - 현재: 5초
   - 문제: 최대 5초 지연
   - 제안: 3초로 줄이기 (부하 증가 주의)

4. **에러 처리 불완전**
   - 현재: 에러 발생 시 로그만 출력
   - 문제: 프론트엔드에 에러 알림 없음
   - 제안: `ai-turn-error` 이벤트 추가

5. **결심 토큰 사용 후 브로드캐스트 없음**
   - 현재: 결심 토큰 사용 후 WebSocket 이벤트 없음
   - 문제: 프론트엔드가 즉시 업데이트되지 않음
   - 제안: 결심 토큰 사용 후에도 브로드캐스트

### 🔍 코드 구조 분석

#### 장점
1. ✅ 트랜잭션 분리로 락 충돌 최소화
2. ✅ 재시도 로직으로 일시적 에러 대응
3. ✅ 중복 실행 방지
4. ✅ WebSocket으로 실시간 동기화

#### 개선 필요
1. ⚠️ 타임아웃 시간 최적화
2. ⚠️ 에러 처리 강화
3. ⚠️ 브로드캐스트 타이밍 조정
4. ⚠️ 체크 간격 최적화

## 권장 개선 사항

### 1. 타임아웃 줄이기
```typescript
// 현재: 10초
await client.query('SET statement_timeout = 10000');

// 제안: 5초
await client.query('SET statement_timeout = 5000');
```

### 2. 결심 토큰 사용 후 브로드캐스트
```typescript
if (shouldUseToken) {
  await this.useResolveToken(gameId, playerId);
  await this.broadcastGameState(gameId); // 추가
}
```

### 3. 에러 이벤트 추가
```typescript
catch (error: any) {
  console.error('❌ AI 턴 실행 중 에러:', error);
  
  // 프론트엔드에 에러 알림
  if (this.io) {
    const roomId = await this.getRoomId(gameId);
    this.io.to(roomId).emit('ai-turn-error', {
      gameId,
      playerId,
      error: error.message
    });
  }
  
  throw error;
}
```

### 4. 체크 간격 줄이기
```typescript
// 현재: 5초
this.checkInterval = setInterval(async () => {
  // ...
}, 5000);

// 제안: 3초
this.checkInterval = setInterval(async () => {
  // ...
}, 3000);
```

## 결론

현재 AI 턴 시스템은 **기본적으로 잘 작동**하지만, 다음과 같은 개선이 필요합니다:

1. **타임아웃 최적화**: 10초 → 5초
2. **브로드캐스트 추가**: 결심 토큰 사용 후
3. **에러 처리 강화**: 프론트엔드 알림 추가
4. **체크 간격 단축**: 5초 → 3초 (선택적)

정상 케이스에서는 **약 8초** 내에 AI 턴이 완료되며, 프론트엔드도 실시간으로 업데이트됩니다.
