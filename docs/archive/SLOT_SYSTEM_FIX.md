# 슬롯 시스템 수정 완료

## 문제점
1. 방장이 1번 슬롯에 표시되지 않음
2. 새 참가자가 2번 슬롯에 추가되지 않음

## 수정 내용

### 백엔드 (RoomService.ts)

#### 1. getRoomState() 개선
- 플레이어를 생성 순서대로 조회 (첫 번째 = 방장)
- 5개 슬롯 정보를 자동으로 생성
- 각 슬롯에 플레이어 정보와 isHost 플래그 추가
- AI 플레이어 자동 감지 (닉네임 패턴 기반)

```typescript
// 슬롯 구조
{
  index: 0-4,
  status: 'user' | 'ai' | 'ban',
  player: {
    id: string,
    userId: string,
    nickname: string,
    isHost: boolean  // index === 0
  }
}
```

#### 2. joinRoom() 개선
- 최대 5명 제한 추가
- 플레이어 수 확인 로직 추가

#### 3. updateSlot() 개선
- room_slots 테이블 의존성 제거
- players 테이블의 created_at 기반으로 순서 관리
- AI 추가 시 해당 슬롯 위치에 정확히 배치

### 프론트엔드 (WaitingRoom.tsx)

#### loadRoomState() 간소화
- 서버에서 받은 슬롯 정보를 그대로 사용
- 클라이언트 측 슬롯 생성 로직 제거
- 서버가 슬롯 관리의 단일 진실 공급원(Single Source of Truth)

## 동작 방식

### 방 생성 시
1. 방장이 방을 생성하면 자동으로 1번 슬롯(index 0)에 배치
2. 나머지 2-5번 슬롯은 빈 상태

### 참가자 입장 시
1. 새 참가자가 입장하면 다음 빈 슬롯에 자동 배치
2. 방장(1번 슬롯)은 항상 고정
3. WebSocket으로 모든 참가자에게 실시간 업데이트

### 슬롯 관리
1. 방장만 2-5번 슬롯 관리 가능
2. 1번 슬롯(방장)은 수정 불가
3. AI 추가/제거, 슬롯 차단 가능

## 테스트 시나리오

### 시나리오 1: 방 생성 및 참가
1. ✅ 플레이어A가 방 생성 → 1번 슬롯에 표시 (👑 방장)
2. ✅ 플레이어B가 참가 → 2번 슬롯에 표시
3. ✅ 플레이어C가 참가 → 3번 슬롯에 표시

### 시나리오 2: AI 추가
1. ✅ 방장이 4번 슬롯에 AI 추가 → 🤖 AI 표시
2. ✅ 방장이 5번 슬롯에 AI 추가 → 🤖 AI 표시

### 시나리오 3: 슬롯 차단
1. ✅ 방장이 5번 슬롯 차단 → 🚫 차단됨 표시
2. ✅ 새 참가자는 4번 슬롯까지만 입장 가능

## 주요 변경 사항

### 데이터베이스
- room_slots 테이블 의존성 제거
- players 테이블의 created_at으로 순서 관리
- 더 간단하고 안정적인 구조

### API 응답
```json
{
  "room": { ... },
  "players": [ ... ],
  "slots": [
    {
      "index": 0,
      "status": "user",
      "player": {
        "id": "...",
        "userId": "...",
        "nickname": "플레이어A",
        "isHost": true
      }
    },
    {
      "index": 1,
      "status": "user",
      "player": {
        "id": "...",
        "userId": "...",
        "nickname": "플레이어B",
        "isHost": false
      }
    },
    {
      "index": 2,
      "status": "user"
    },
    ...
  ]
}
```

## 다음 단계
1. 로컬 테스트로 슬롯 시스템 검증
2. 여러 명이 동시에 입장하는 경우 테스트
3. AI 추가/제거 기능 테스트
4. 배포 후 실제 환경에서 검증
