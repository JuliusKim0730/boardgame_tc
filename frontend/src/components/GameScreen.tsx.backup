import { useState, useEffect } from 'react';
import { api } from '../services/api';
import { socketService } from '../services/socket';
import GameBoard from './GameBoard';
import PlayerInfo from './PlayerInfo';
import HandCards from './HandCards';
import ChanceOptionModal from './ChanceOptionModal';
import ContributeModal from './ContributeModal';
import ResultScreen from './ResultScreen';
import './GameScreen.css';

interface Props {
  roomId: string;
  gameId: string;
  playerId: string;
  userId: string;
  onBackToLobby: () => void;
}

interface PlayerState {
  id: string;
  money: number;
  position: number;
  resolve_token: number;
  traits: any;
  hand_cards?: any[];
}

interface GameState {
  day: number;
  currentTurnPlayerId: string | null;
  status: string;
  travelTheme: string | null;
  jointPlanCardId: string | null;
}

function GameScreen({ roomId, gameId, playerId, onBackToLobby }: Props) {
  const [gameState, setGameState] = useState<GameState>({
    day: 1,
    currentTurnPlayerId: null,
    status: 'running',
    travelTheme: null,
    jointPlanCardId: null
  });
  const [playerState, setPlayerState] = useState<PlayerState | null>(null);
  const [allPlayers, setAllPlayers] = useState<any[]>([]);
  const [_selectedPosition, setSelectedPosition] = useState<number | null>(null);
  const [message, setMessage] = useState('ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤!');
  const [is2Player, setIs2Player] = useState(false);
  const [showChanceOption, setShowChanceOption] = useState(false);
  const [showContributeModal, setShowContributeModal] = useState(false);
  const [showResult, setShowResult] = useState(false);
  const [isFirstHouseVisit, setIsFirstHouseVisit] = useState(true);
  const [hasMoved, setHasMoved] = useState(false);
  const [hasActed, setHasActed] = useState(false);

  // ê²Œì„ ìƒíƒœ ë¡œë“œ
  const loadGameState = async () => {
    try {
      const response = await api.getGameState(gameId);
      const { game, players } = response.data;
      
      setGameState({
        day: game.day,
        currentTurnPlayerId: game.currentTurnPlayerId,
        status: game.status,
        travelTheme: game.travelTheme,
        jointPlanCardId: game.jointPlanCardId
      });
      
      setAllPlayers(players);
      
      // ë‚´ í”Œë ˆì´ì–´ ìƒíƒœ ì°¾ê¸°
      const myState = players.find((p: any) => p.player_id === playerId);
      if (myState) {
        setPlayerState(myState);
      }
      
      // ê²Œì„ ì¢…ë£Œ ì²´í¬
      if (game.status === 'finished') {
        setShowResult(true);
      }
    } catch (error) {
      console.error('Failed to load game state:', error);
    }
  };

  useEffect(() => {
    // ì´ˆê¸° ë¡œë“œ
    loadGameState();
    
    // í”Œë ˆì´ì–´ ìˆ˜ í™•ì¸ (2ì¸ í”Œë ˆì´ ê°ì§€)
    const fetchPlayers = async () => {
      try {
        const response = await api.getRoom(roomId);
        const players = response.data?.players || [];
        if (players?.length === 2) {
          setIs2Player(true);
        }
      } catch (error) {
        console.error('Failed to fetch players:', error);
      }
    };
    fetchPlayers();

    // WebSocket ì—°ê²°
    const socket = socketService.connect(roomId);

    socket.on('turn-started', (data: any) => {
      setGameState(prev => ({ ...prev, currentTurnPlayerId: data.playerId, day: data.day }));
      setHasMoved(false);
      setHasActed(false);
      setSelectedPosition(null);
      
      if (data.playerId === playerId) {
        setMessage('ë‹¹ì‹ ì˜ í„´ì…ë‹ˆë‹¤! ì´ë™í•  ì¹¸ì„ ì„ íƒí•˜ì„¸ìš”.');
      } else {
        setMessage('ë‹¤ë¥¸ í”Œë ˆì´ì–´ì˜ í„´ì…ë‹ˆë‹¤...');
      }
      
      loadGameState();
    });

    socket.on('state-updated', () => {
      loadGameState();
    });

    socket.on('player-moved', (data: any) => {
      if (data.playerId === playerId) {
        setHasMoved(true);
        setMessage('í–‰ë™ì„ ì„ íƒí•˜ì„¸ìš” (1~6ë²ˆ)');
      }
      loadGameState();
    });

    socket.on('action-completed', (data: any) => {
      if (data.playerId === playerId) {
        setHasActed(true);
      }
      loadGameState();
    });

    socket.on('chance-request', (data: any) => {
      if (data.targetPlayerId === playerId) {
        setMessage(data.message);
      }
    });

    socket.on('house-first-visit-bonus', (data: any) => {
      if (data.playerId === playerId) {
        setMessage('ğŸ‰ ì§‘ì•ˆì¼ ì²« ë°©ë¬¸ ë³´ë„ˆìŠ¤ +500TC!');
        setIsFirstHouseVisit(false);
      }
    });

    socket.on('resolve-token-recovered', (data: any) => {
      if (data.playerId === playerId) {
        setMessage(`ğŸ”¥ ê²°ì‹¬ í† í° íšŒë³µ! (${data.newCount}ê°œ)`);
      }
      loadGameState();
    });

    socket.on('game-ended', () => {
      setMessage('ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! ìµœì¢… ì •ì‚° ì¤‘...');
      setTimeout(() => {
        setShowResult(true);
      }, 2000);
    });

    socket.on('day-7-started', () => {
      setMessage('ğŸ“… 7ì¼ì°¨ ì‹œì‘! ê²°ì‹¬ í† í° íšŒë³µ ì²´í¬ ì¤‘...');
      api.checkResolveRecovery(gameId).catch(console.error);
    });

    return () => {
      socketService.disconnect();
    };
  }, [roomId, playerId, gameId]);

  const handleMove = async (position: number) => {
    if (gameState.currentTurnPlayerId !== playerId) {
      setMessage('ë‹¹ì‹ ì˜ í„´ì´ ì•„ë‹™ë‹ˆë‹¤!');
      return;
    }

    if (hasMoved) {
      setMessage('ì´ë¯¸ ì´ë™í–ˆìŠµë‹ˆë‹¤!');
      return;
    }

    try {
      await api.move(gameId, playerId, position);
      setSelectedPosition(position);
      setHasMoved(true);
      setMessage(`${position}ë²ˆ ì¹¸ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤. í–‰ë™ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤...`);
      
      // ìë™ìœ¼ë¡œ í•´ë‹¹ ì¹¸ì˜ í–‰ë™ ìˆ˜í–‰
      setTimeout(() => {
        handleAction(position);
      }, 500);
      
      loadGameState();
    } catch (error: any) {
      setMessage(error.response?.data?.error || 'ì´ë™ ì‹¤íŒ¨');
    }
  };

  const handleAction = async (actionType: number) => {
    if (gameState.currentTurnPlayerId !== playerId) {
      setMessage('ë‹¹ì‹ ì˜ í„´ì´ ì•„ë‹™ë‹ˆë‹¤!');
      return;
    }

    if (!hasMoved) {
      setMessage('ë¨¼ì € ì´ë™í•´ì•¼ í•©ë‹ˆë‹¤!');
      return;
    }

    if (hasActed) {
      setMessage('ì´ë¯¸ í–‰ë™í–ˆìŠµë‹ˆë‹¤!');
      return;
    }

    // 2ì¸ ì „ìš©: ì°¬ìŠ¤ ì¹¸(5ë²ˆ) ì„ íƒ ëª¨ë‹¬
    if (is2Player && actionType === 5) {
      setShowChanceOption(true);
      return;
    }

    try {
      const response = await api.performAction(gameId, playerId, actionType);
      setHasActed(true);
      setMessage(`í–‰ë™ ì™„ë£Œ: ${getActionName(actionType)}`);
      
      // ì§‘ì•ˆì¼ ì²« ë°©ë¬¸ ì²´í¬
      if (is2Player && actionType === 3 && isFirstHouseVisit) {
        setMessage('ğŸ‰ ì§‘ì•ˆì¼ ì²« ë°©ë¬¸ ë³´ë„ˆìŠ¤ +500TC!');
        setIsFirstHouseVisit(false);
      }
      
      loadGameState();
      
      // ì°¬ìŠ¤ ì¹´ë“œ íšë“ ì‹œ ì•Œë¦¼
      if (response.data?.card) {
        setMessage(`ğŸ´ ${response.data.card.name} ì¹´ë“œë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!`);
      }
      
      // ìë™ í„´ ì¢…ë£Œ
      setTimeout(async () => {
        try {
          await api.endTurn(gameId, playerId);
          setMessage('í„´ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
          setHasMoved(false);
          setHasActed(false);
        } catch (error: any) {
          setMessage(error.response?.data?.error || 'í„´ ì¢…ë£Œ ì‹¤íŒ¨');
        }
      }, 1500);
    } catch (error: any) {
      setMessage(error.response?.data?.error || 'í–‰ë™ ì‹¤íŒ¨');
    }
  };

  const handleChanceOptionSelect = async (option: 'card' | 'money') => {
    setShowChanceOption(false);
    
    try {
      const response = await api.selectChanceOption(gameId, playerId, option);
      setHasActed(true);
      
      if (option === 'money') {
        setMessage(`ğŸ’° 500TCë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!`);
      } else {
        setMessage(`ğŸ´ ${response.data?.card?.name || 'ì°¬ìŠ¤ ì¹´ë“œ'}ë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!`);
      }
      
      loadGameState();
      
      // ìë™ í„´ ì¢…ë£Œ
      setTimeout(async () => {
        try {
          await api.endTurn(gameId, playerId);
          setMessage('í„´ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
          setHasMoved(false);
          setHasActed(false);
        } catch (error: any) {
          setMessage(error.response?.data?.error || 'í„´ ì¢…ë£Œ ì‹¤íŒ¨');
        }
      }, 1500);
    } catch (error: any) {
      setMessage(error.response?.data?.error || 'ì„ íƒ ì‹¤íŒ¨');
    }
  };

  const handleContribute = async (amount: number) => {
    try {
      await api.contribute(gameId, playerId, amount);
      setMessage(`ê³µë™ ê³„íšì— ${amount.toLocaleString()}TC ê¸°ì—¬í–ˆìŠµë‹ˆë‹¤!`);
      setShowContributeModal(false);
      loadGameState();
    } catch (error: any) {
      setMessage(error.response?.data?.error || 'ê¸°ì—¬ ì‹¤íŒ¨');
    }
  };

  const getActionName = (type: number): string => {
    const names = ['', 'ë¬´ë£Œ ê³„íš', 'ì¡°ì‚¬í•˜ê¸°', 'ì§‘ì•ˆì¼', 'ì—¬í–‰ ì§€ì›', 'ì°¬ìŠ¤', 'ììœ  í–‰ë™'];
    return names[type] || 'ì•Œ ìˆ˜ ì—†ìŒ';
  };

  const isMyTurn = gameState.currentTurnPlayerId === playerId;

  if (showResult) {
    return (
      <ResultScreen
        gameId={gameId}
        roomId={roomId}
        playerId={playerId}
        onRestart={() => {
          setShowResult(false);
          loadGameState();
        }}
        onBackToLobby={onBackToLobby}
      />
    );
  }

  return (
    <div className="game-screen">
      <div className="game-header">
        <div className="game-info">
          <h2>ğŸŒ™ ì—´ë„¤ ë°¤ì˜ ê¿ˆ</h2>
          <div className="day-counter">
            Day {gameState.day} / 14
            {is2Player && <span className="mode-badge">2ì¸ ëª¨ë“œ</span>}
          </div>
        </div>
        
        {/* ë‚´ ì—¬í–‰ì§€ ì¹´ë“œ - ìš°ì¸¡ ìƒë‹¨ */}
        {allPlayers.find(p => p.player_id === playerId)?.travelCard && (
          <div className="header-travel-card">
            <div className="travel-card-compact">
              <div className="travel-card-icon">ğŸ¯</div>
              <div className="travel-card-info">
                <div className="travel-card-title">ë‚´ ì—¬í–‰ì§€</div>
                <div className="travel-card-name-compact">
                  {allPlayers.find(p => p.player_id === playerId)?.travelCard.name}
                </div>
                {JSON.parse(allPlayers.find(p => p.player_id === playerId)?.travelCard.effects || '{}').weights && (
                  <div className="weights-compact">
                    {Object.entries(JSON.parse(allPlayers.find(p => p.player_id === playerId)?.travelCard.effects || '{}').weights || {})
                      .sort(([, a]: any, [, b]: any) => b - a)
                      .map(([trait, weight]: [string, any]) => (
                        <span key={trait} className={`weight-badge-compact weight-${weight}`}>
                          {trait} Ã—{weight}
                        </span>
                      ))}
                  </div>
                )}
              </div>
            </div>
          </div>
        )}
        
        <button className="btn-exit" onClick={onBackToLobby}>
          ë‚˜ê°€ê¸°
        </button>
      </div>

      <div className="message-bar">
        <div className="message-content">
          <p>{message}</p>
          {isMyTurn && (
            <div className="turn-status active">
              {!hasMoved && 'ğŸ¯ ì´ë™ í•„ìš”'}
              {hasMoved && !hasActed && 'âš¡ í–‰ë™ í•„ìš”'}
              {hasMoved && hasActed && 'âœ… ì™„ë£Œ'}
            </div>
          )}
          {!isMyTurn && gameState.currentTurnPlayerId && (
            <div className="turn-status waiting">
              â³ {allPlayers.find(p => p.player_id === gameState.currentTurnPlayerId)?.nickname || 'ë‹¤ë¥¸ í”Œë ˆì´ì–´'}ì˜ í„´
            </div>
          )}
        </div>
      </div>

      <div className="game-content">
        <div className="left-panel">
          <PlayerInfo
            money={playerState?.money || 3000}
            position={playerState?.position || 1}
            resolveToken={playerState?.resolve_token || 1}
            traits={playerState?.traits || {}}
          />
          
          <div className="other-players">
            <h3>í”Œë ˆì´ì–´ ëª©ë¡</h3>
            {allPlayers
              .sort((a, b) => a.turn_order - b.turn_order)
              .map(p => {
                const isMe = p.player_id === playerId;
                const isCurrentTurn = gameState.currentTurnPlayerId === p.player_id;
                
                return (
                  <div 
                    key={p.id} 
                    className={`other-player-item ${isMe ? 'me' : ''} ${isCurrentTurn ? 'current-turn' : ''}`}
                  >
                    <div className="player-header">
                      <div className="player-name">
                        {isCurrentTurn && 'ğŸ¯ '}
                        {p.nickname || `í”Œë ˆì´ì–´ ${p.turn_order + 1}`}
                        {isMe && ' (ë‚˜)'}
                      </div>
                      <div className="player-order">#{p.turn_order + 1}</div>
                    </div>
                    <div className="player-stats">
                      ğŸ’° {p.money?.toLocaleString()}TC | ğŸ“ {p.position}ë²ˆ
                    </div>
                    {p.travelCard && (
                      <div className="player-travel">
                        ğŸ¯ {p.travelCard.name}
                      </div>
                    )}
                  </div>
                );
              })}
          </div>
        </div>

        <div className="center-panel">
          <div className="board-container">
            <h3 className="board-title">
              {isMyTurn ? 'ì´ë™í•  ì¹¸ì„ ì„ íƒí•˜ì„¸ìš”' : 'ê²Œì„ ë³´ë“œ'}
            </h3>
            <GameBoard
              currentPosition={playerState?.position || 1}
              onPositionClick={handleMove}
              disabled={!isMyTurn || hasMoved}
            />
            <div className="board-hint">
              {isMyTurn && !hasMoved && 'ğŸ’¡ ì¸ì ‘í•œ ì¹¸(ë°ê²Œ í‘œì‹œ)ì„ í´ë¦­í•˜ì—¬ ì´ë™í•˜ì„¸ìš”'}
              {isMyTurn && hasMoved && !hasActed && 'âš¡ í–‰ë™ì´ ìë™ìœ¼ë¡œ ìˆ˜í–‰ë©ë‹ˆë‹¤'}
              {!isMyTurn && 'â³ ë‹¤ë¥¸ í”Œë ˆì´ì–´ì˜ í„´ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...'}
            </div>
          </div>
          </div>
        </div>

        <div className="right-panel">
          <HandCards cards={playerState?.hand_cards || []} />
          
          <div className="joint-plan-section card">
            <h3>ê³µë™ ê³„íš</h3>
            <div className="joint-plan-info">
              <p>ëª©í‘œ: 10,000TC</p>
              <p>í˜„ì¬: ì§„í–‰ ì¤‘</p>
              <button 
                className="btn-contribute"
                onClick={() => setShowContributeModal(true)}
                disabled={!playerState || playerState.money < 1000}
              >
                ê¸°ì—¬í•˜ê¸°
              </button>
            </div>
          </div>
        </div>
      </div>

      <ChanceOptionModal
        isOpen={showChanceOption}
        onSelect={handleChanceOptionSelect}
      />

      {showContributeModal && (
        <ContributeModal
          currentMoney={playerState?.money || 0}
          targetAmount={10000}
          currentAmount={0}
          onContribute={handleContribute}
          onClose={() => setShowContributeModal(false)}
        />
      )}
    </div>
  );
}

export default GameScreen;
