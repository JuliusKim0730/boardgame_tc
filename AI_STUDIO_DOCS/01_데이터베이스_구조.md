# 데이터베이스 구조

## 개요

PostgreSQL 기반, UUID 사용, JSONB 활용

## 주요 테이블

### 1. users (사용자)
```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  nickname TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```
- 게임 참여자 정보
- 닉네임만 저장 (인증 없음)

### 2. rooms (방)
```sql
CREATE TABLE rooms (
  id UUID PRIMARY KEY,
  code TEXT UNIQUE NOT NULL,  -- 4자리 코드 (예: ABCD)
  status TEXT CHECK (status IN ('waiting', 'in_progress')),
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```
- 게임 방 정보
- `waiting`: 대기 중
- `in_progress`: 게임 진행 중

### 3. games (게임)
```sql
CREATE TABLE games (
  id UUID PRIMARY KEY,
  room_id UUID REFERENCES rooms(id),
  day INT DEFAULT 1,                    -- 현재 날짜 (1~14)
  current_turn_player_id UUID,          -- 현재 턴 플레이어
  travel_theme TEXT,                    -- 여행 테마 (T1~T10)
  joint_plan_card_id UUID,              -- 공동 계획 카드
  status TEXT CHECK (status IN ('setting', 'running', 'finalizing', 'finished')),
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```
- 게임 진행 상태
- `setting`: 초기화 중
- `running`: 진행 중
- `finalizing`: 최종 정산 중
- `finished`: 종료

### 4. players (플레이어)
```sql
CREATE TABLE players (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),
  room_id UUID REFERENCES rooms(id)
);
```
- 방에 참여한 플레이어

### 5. player_states (플레이어 상태)
```sql
CREATE TABLE player_states (
  id UUID PRIMARY KEY,
  game_id UUID REFERENCES games(id),
  player_id UUID REFERENCES players(id),
  money INT DEFAULT 3000,               -- 소지금
  position INT DEFAULT 1,               -- 현재 위치 (1~6)
  resolve_token INT DEFAULT 1,          -- 결심 토큰
  traits JSONB DEFAULT '{...}',         -- 특성 점수
  turn_order INT NOT NULL,              -- 턴 순서
  status TEXT DEFAULT 'active',
  last_position INT                     -- 직전 위치 (연속 사용 방지)
);
```

**traits 구조**:
```json
{
  "taste": 0,      // 맛
  "history": 0,    // 역사
  "nature": 0,     // 자연
  "culture": 0,    // 문화
  "leisure": 0,    // 여가
  "water": 0,      // 물
  "memory": 0      // 추억
}
```

### 6. cards (카드 마스터)
```sql
CREATE TABLE cards (
  id UUID PRIMARY KEY,
  type TEXT NOT NULL,           -- 'plan', 'freeplan', 'house', 'support', 'chance', 'travel', 'joint'
  code TEXT UNIQUE NOT NULL,    -- 'P1', 'F1', 'H1', 'S1', 'CH1', 'T1', 'J1'
  name TEXT NOT NULL,
  cost INT,                     -- 구매 비용 (plan, freeplan만)
  effects JSONB NOT NULL,       -- 효과
  metadata JSONB                -- 추가 정보
);
```

**카드 타입**:
- `plan`: 계획 카드 (40장) - 조사하기에서 획득
- `freeplan`: 무료 계획 카드 (10장) - 무료계획에서 획득
- `house`: 집안일 카드 (10장) - 즉시 효과
- `support`: 여행 지원 카드 (10장) - 즉시 효과
- `chance`: 찬스 카드 (25장) - 다양한 효과
- `travel`: 여행지 카드 (10장) - 게임 시작 시 배정
- `joint`: 공동 계획 카드 (2장) - 게임당 1장 선택

**effects 예시**:
```json
// 계획 카드
{
  "taste": 2,
  "nature": 1,
  "memory": 1
}

// 집안일 카드
{
  "money": 500,
  "memory": 1
}

// 찬스 카드
{
  "money": 1000
}
```

### 7. decks (덱)
```sql
CREATE TABLE decks (
  id UUID PRIMARY KEY,
  game_id UUID REFERENCES games(id),
  type TEXT NOT NULL,           -- 'plan', 'freeplan', 'house', 'support', 'chance'
  card_order JSONB NOT NULL     -- [uuid, uuid, ...] 카드 순서
);
```
- 게임마다 5개 덱 생성
- 카드를 뽑으면 `card_order`에서 제거

### 8. hands (손패)
```sql
CREATE TABLE hands (
  id UUID PRIMARY KEY,
  player_state_id UUID REFERENCES player_states(id),
  card_id UUID REFERENCES cards(id),
  seq INT NOT NULL              -- 순서
);
```
- plan, freeplan 카드만 손패에 추가
- 최종 구매 시 사용

### 9. purchased (구매한 카드)
```sql
CREATE TABLE purchased (
  id UUID PRIMARY KEY,
  player_state_id UUID REFERENCES player_states(id),
  card_id UUID REFERENCES cards(id),
  price_paid INT NOT NULL,
  purchased_at TIMESTAMPTZ DEFAULT NOW()
);
```
- 최종 구매한 카드 기록
- 점수 계산에 사용

### 10. turns (턴)
```sql
CREATE TABLE turns (
  id UUID PRIMARY KEY,
  game_id UUID REFERENCES games(id),
  day INT NOT NULL,
  player_state_id UUID REFERENCES player_states(id),
  started_at TIMESTAMPTZ DEFAULT NOW(),
  ended_at TIMESTAMPTZ
);
```
- 각 플레이어의 턴 기록

### 11. joint_plan_contributions (공동 계획 기여)
```sql
CREATE TABLE joint_plan_contributions (
  id UUID PRIMARY KEY,
  game_id UUID REFERENCES games(id),
  player_state_id UUID REFERENCES player_states(id),
  amount INT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```
- 공동 계획 기여 내역
- 최다 기여자 보너스 계산

### 12. game_results (게임 결과)
```sql
CREATE TABLE game_results (
  id UUID PRIMARY KEY,
  game_id UUID REFERENCES games(id),
  player_state_id UUID REFERENCES player_states(id),
  total_score INT NOT NULL,
  breakdown JSONB NOT NULL
);
```

**breakdown 구조**:
```json
{
  "baseScore": 1500,
  "bonusScore": 500,
  "jointPlanBonus": 300,
  "details": {
    "taste": { "points": 10, "multiplier": 3, "score": 300 },
    "history": { "points": 5, "multiplier": 2, "score": 100 },
    ...
  }
}
```

### 13. event_logs (이벤트 로그)
```sql
CREATE TABLE event_logs (
  id UUID PRIMARY KEY,
  game_id UUID REFERENCES games(id),
  event_type TEXT NOT NULL,
  data JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```
- 게임 내 모든 이벤트 기록
- 디버깅 및 리플레이에 사용

**주요 event_type**:
- `move`: 이동
- `action_1` ~ `action_6`: 행동
- `resolve_token_used`: 결심 토큰 사용
- `chance_money_bonus`: 찬스 돈 보너스
- `joint_plan_contribution`: 공동 계획 기여

## 인덱스

```sql
CREATE INDEX idx_player_states_game ON player_states(game_id);
CREATE INDEX idx_turns_game_day ON turns(game_id, day);
CREATE INDEX idx_hands_player_state ON hands(player_state_id);
CREATE INDEX idx_joint_contributions_game ON joint_plan_contributions(game_id);
```

## 데이터 흐름

### 게임 시작
1. `rooms` 생성 (code 생성)
2. `users` 생성 (닉네임)
3. `players` 생성 (방 참여)
4. `games` 생성 (게임 초기화)
5. `player_states` 생성 (플레이어별 상태)
6. `decks` 생성 (5개 덱 셔플)
7. 여행지 카드 배정 (`purchased`에 추가)

### 턴 진행
1. `turns` 레코드 생성
2. 이동: `player_states.position` 업데이트
3. 행동: 카드 드로우 → `hands` 또는 즉시 효과
4. 턴 종료: `turns.ended_at` 업데이트
5. 다음 플레이어로 전환

### 최종 정산
1. 구매: `hands` → `purchased`
2. 특성 변환: `player_states.traits` 업데이트
3. 점수 계산: `game_results` 생성
4. 게임 종료: `games.status = 'finished'`

## 마이그레이션

### v4.1 주요 변경사항
- `player_states.last_position` 추가 (연속 사용 방지)
- `cards.metadata` 추가 (카드 추가 정보)
- `event_logs` 테이블 추가 (이벤트 로깅)

### 실행 방법
```bash
psql -d boardgame -f backend/src/db/migration_v4.1.sql
```

## 주의사항

1. **UUID 사용**: 모든 ID는 UUID
2. **JSONB 활용**: 유연한 데이터 구조 (traits, effects, metadata)
3. **CASCADE 삭제**: 방 삭제 시 관련 데이터 자동 삭제
4. **트랜잭션**: 중요한 작업은 트랜잭션 사용
5. **인덱스**: 자주 조회하는 컬럼에 인덱스 추가
